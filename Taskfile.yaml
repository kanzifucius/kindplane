version: "3"

vars:
  BINARY_NAME: kindplane
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "dev"
  COMMIT:
    sh: git rev-parse --short HEAD 2>/dev/null || echo "none"
  BUILD_TIME:
    sh: date -u '+%Y-%m-%dT%H:%M:%SZ'
  LDFLAGS: >-
    -s -w
    -X main.Version={{.VERSION}}
    -X main.Commit={{.COMMIT}}
    -X main.BuildTime={{.BUILD_TIME}}

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  # =============================================================================
  # Build tasks
  # =============================================================================

  build:
    desc: Build the binary
    cmds:
      - go build -ldflags "{{.LDFLAGS}}" -o bin/{{.BINARY_NAME}} ./cmd/kindplane

  build:all:
    desc: Build for all platforms
    deps: [build:clean]
    cmds:
      - GOOS=darwin GOARCH=amd64 go build -ldflags "{{.LDFLAGS}}" -o bin/{{.BINARY_NAME}}-darwin-amd64 ./cmd/kindplane
      - GOOS=darwin GOARCH=arm64 go build -ldflags "{{.LDFLAGS}}" -o bin/{{.BINARY_NAME}}-darwin-arm64 ./cmd/kindplane
      - GOOS=linux GOARCH=amd64 go build -ldflags "{{.LDFLAGS}}" -o bin/{{.BINARY_NAME}}-linux-amd64 ./cmd/kindplane
      - GOOS=linux GOARCH=arm64 go build -ldflags "{{.LDFLAGS}}" -o bin/{{.BINARY_NAME}}-linux-arm64 ./cmd/kindplane
      - GOOS=windows GOARCH=amd64 go build -ldflags "{{.LDFLAGS}}" -o bin/{{.BINARY_NAME}}-windows-amd64.exe ./cmd/kindplane

  install:
    desc: Install locally to $GOPATH/bin (alias for build:install)
    cmds:
      - go install -ldflags "{{.LDFLAGS}}" ./cmd/kindplane
      - echo "✓ Installed {{.BINARY_NAME}} to $${GOPATH:-$$HOME/go}/bin/{{.BINARY_NAME}}"

  uninstall:
    desc: Remove binary from $GOPATH/bin (same location as install)
    cmds:
      - rm -f $${GOPATH:-$$HOME/go}/bin/{{.BINARY_NAME}}
      - echo "✓ Uninstalled {{.BINARY_NAME}}"

  build:clean:
    desc: Clean build artifacts
    cmds:
      - rm -rf bin/
      - rm -f coverage.out coverage.html

  build:tidy:
    desc: Tidy and verify dependencies
    cmds:
      - go mod tidy
      - go mod verify

  # =============================================================================
  # Development tasks
  # =============================================================================

  dev:
    desc: Build and show help
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} --help

  dev:init:
    desc: Build and run init command
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} init --force

  dev:up:
    desc: Build and run up command
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} up

  dev:down:
    desc: Build and run down command
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} down

  dev:status:
    desc: Build and run status command
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} status

  dev:run:
    desc: "Build and run any command (usage: task dev:run -- status)"
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} {{.CLI_ARGS}}

  # =============================================================================
  # Test tasks
  # =============================================================================

  test:
    desc: Run tests
    cmds:
      - go test -v -race ./...

  test:coverage:
    desc: Run tests with coverage
    cmds:
      - go test -v -race -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
      - echo "Coverage report generated at coverage.html"

  test:short:
    desc: Run short tests only
    cmds:
      - go test -v -short ./...

  # =============================================================================
  # Lint and format tasks
  # =============================================================================

  lint:
    desc: Run linter
    cmds:
      - golangci-lint run ./...

  lint:fix:
    desc: Run linter and fix issues
    cmds:
      - golangci-lint run --fix ./...

  fmt:
    desc: Format code
    cmds:
      - go fmt ./...
      - command -v goimports >/dev/null && goimports -w . || echo "goimports not installed, skipping"

  # =============================================================================
  # Quality assurance (top-level utility)
  # =============================================================================

  check:
    desc: Run all checks (fmt, lint, test, schema)
    cmds:
      - task: fmt
      - task: lint
      - task: test
      - task: schema:generate

  # =============================================================================
  # Release tasks
  # =============================================================================

  release:next:
    desc: "Show next version (usage: task release:next TYPE=patch|minor|major PRERELEASE=alpha|beta|rc)"
    vars:
      TYPE: '{{.TYPE | default "patch"}}'
      PRERELEASE: '{{.PRERELEASE | default ""}}'
    cmds:
      - |
        # Get the latest tag
        LATEST_TAG=$(git tag -l 'v*' --sort=-v:refname | head -1)
        if [ -z "$LATEST_TAG" ]; then
          LATEST_TAG="v0.0.0"
        fi

        # Parse version components (handle pre-release suffix)
        BASE_VERSION=$(echo "$LATEST_TAG" | sed 's/-.*//')
        MAJOR=$(echo "$BASE_VERSION" | sed 's/v\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\1/')
        MINOR=$(echo "$BASE_VERSION" | sed 's/v\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\2/')
        PATCH=$(echo "$BASE_VERSION" | sed 's/v\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\)/\3/')

        # Calculate next versions
        NEXT_PATCH="v${MAJOR}.${MINOR}.$((PATCH+1))"
        NEXT_MINOR="v${MAJOR}.$((MINOR+1)).0"
        NEXT_MAJOR="v$((MAJOR+1)).0.0"

        # Determine the selected next version
        case "{{.TYPE}}" in
          major) NEXT_VERSION="$NEXT_MAJOR" ;;
          minor) NEXT_VERSION="$NEXT_MINOR" ;;
          patch) NEXT_VERSION="$NEXT_PATCH" ;;
          *) NEXT_VERSION="$NEXT_PATCH" ;;
        esac

        # Handle pre-release suffix
        PRERELEASE="{{.PRERELEASE}}"
        if [ -n "$PRERELEASE" ]; then
          EXISTING=$(git tag -l "${NEXT_VERSION}-${PRERELEASE}.*" --sort=-v:refname | head -1)
          if [ -n "$EXISTING" ]; then
            NUM=$(echo "$EXISTING" | sed "s/.*-${PRERELEASE}\.\([0-9]*\)/\1/")
            NEXT_VERSION="${NEXT_VERSION}-${PRERELEASE}.$((NUM+1))"
          else
            NEXT_VERSION="${NEXT_VERSION}-${PRERELEASE}.1"
          fi
        fi

        echo ""
        echo "Current version: $LATEST_TAG"
        echo ""
        echo "Next versions:"
        echo "  patch:  $NEXT_PATCH"
        echo "  minor:  $NEXT_MINOR"
        echo "  major:  $NEXT_MAJOR"
        echo ""
        echo "Selected ({{.TYPE}}): $NEXT_VERSION"
        echo ""
        echo "To create this release:"
        echo "  task release:tag TAG=$NEXT_VERSION"

  release:tag:
    desc: "Create and push a release tag (usage: task release:tag TAG=v1.0.0)"
    requires:
      vars: [TAG]
    preconditions:
      - sh: echo "{{.TAG}}" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$'
        msg: "TAG must be a valid semver (e.g., v1.0.0 or v1.0.0-rc.1)"
      - sh: '[ -z "$(git status --porcelain)" ]'
        msg: "Working directory is not clean. Commit or stash changes first."
      - sh: '[ "$(git branch --show-current)" = "main" ]'
        msg: "Must be on main branch to create a release"
      - sh: git fetch origin main --tags
        msg: "Failed to fetch from origin"
      - sh: '[ "$(git rev-parse HEAD)" = "$(git rev-parse origin/main)" ]'
        msg: "Local main is not up to date with origin/main. Run 'git pull' first."
      - sh: 'test -z "$(git tag -l "{{.TAG}}")"'
        msg: "Tag {{.TAG}} already exists"
    cmds:
      - echo "Creating release {{.TAG}} at commit $(git rev-parse --short HEAD)..."
      - git tag -a "{{.TAG}}" -m "Release {{.TAG}}"
      - git push origin "{{.TAG}}"
      - echo "Tag {{.TAG}} pushed. GitHub Actions release workflow triggered."
      - echo "Monitor at https://github.com/kanzifucius/kindplane/actions"

  release:delete:
    desc: "Delete a GitHub release and its tag (usage: task release:delete TAG=v1.0.0)"
    requires:
      vars: [TAG]
    preconditions:
      - sh: echo "{{.TAG}}" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$'
        msg: "TAG must be a valid semver (e.g., v1.0.0 or v1.0.0-rc.1)"
      - sh: command -v gh >/dev/null 2>&1
        msg: "GitHub CLI (gh) is required but not installed"
      - sh: git tag -l "{{.TAG}}" | grep -qxF "{{.TAG}}"
        msg: "Tag {{.TAG}} does not exist locally"
    prompt: "Are you sure you want to delete release {{.TAG}}? This cannot be undone."
    cmds:
      - echo "Deleting GitHub release {{.TAG}}..."
      - gh release delete "{{.TAG}}" --yes || echo "No GitHub release found for {{.TAG}}"
      - echo "Deleting remote tag {{.TAG}}..."
      - git push origin --delete "{{.TAG}}" || echo "Remote tag {{.TAG}} not found"
      - echo "Deleting local tag {{.TAG}}..."
      - git tag -d "{{.TAG}}" || echo "Local tag {{.TAG}} not found"
      - echo "Release {{.TAG}} deleted successfully."

  release:snapshot:
    desc: Create a snapshot release (requires goreleaser)
    cmds:
      - goreleaser release --snapshot --clean

  release:tags:
    desc: List all release tags
    cmds:
      - git tag -l --sort=-v:refname 'v*'

  # =============================================================================
  # Tools tasks
  # =============================================================================

  tools:install:
    desc: Install development tools
    cmds:
      - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
      - go install golang.org/x/tools/cmd/goimports@latest
      - go install github.com/goreleaser/goreleaser@latest

  hooks:install:
    desc: Install Git pre-commit hook
    cmds:
      - |
        if [ ! -f scripts/pre-commit ]; then
          echo "Error: scripts/pre-commit not found"
          exit 1
        fi
        cp scripts/pre-commit .git/hooks/pre-commit
        chmod +x .git/hooks/pre-commit
        echo "✓ Pre-commit hook installed at .git/hooks/pre-commit"

  # =============================================================================
  # Documentation tasks
  # =============================================================================

  docs:generate:
    desc: Generate CLI reference documentation from Cobra commands
    cmds:
      - go run ./cmd/gendocs
      - echo "CLI documentation generated in docs/cli-reference/"

  schema:generate:
    desc: Generate kindplane.schema.json from config package types
    cmds:
      - go run ./cmd/genschema
      - echo "Schema written to kindplane.schema.json"

  docs:serve:
    desc: Serve documentation locally with hot reload (Docker)
    cmds:
      - docker run --rm -it -p 8000:8000 -v {{.ROOT_DIR}}:/docs squidfunk/mkdocs-material serve --dev-addr=0.0.0.0:8000

  docs:build:
    desc: Build documentation site (Docker)
    cmds:
      - docker run --rm -v {{.ROOT_DIR}}:/docs squidfunk/mkdocs-material build --strict

  docs:clean:
    desc: Remove built documentation
    cmds:
      - rm -rf site/

  docs:version:deploy:
    desc: "Deploy a versioned doc (usage: task docs:version:deploy VERSION=1.0.0)"
    requires:
      vars: [VERSION]
    cmds:
      - |
        docker run --rm -v {{.ROOT_DIR}}:/docs -v ~/.gitconfig:/root/.gitconfig:ro \
          -w /docs squidfunk/mkdocs-material \
          sh -c "pip install mike && mike deploy {{.VERSION}}"

  docs:version:list:
    desc: List all deployed documentation versions
    cmds:
      - |
        docker run --rm -v {{.ROOT_DIR}}:/docs -w /docs squidfunk/mkdocs-material \
          sh -c "pip install mike && mike list"

  docs:version:serve:
    desc: Serve versioned documentation locally
    cmds:
      - |
        docker run --rm -it -p 8000:8000 -v {{.ROOT_DIR}}:/docs -w /docs squidfunk/mkdocs-material \
          sh -c "pip install mike && mike serve --dev-addr=0.0.0.0:8000"

  docs:version:delete:
    desc: "Delete a versioned doc (usage: task docs:version:delete VERSION=1.0.0)"
    requires:
      vars: [VERSION]
    prompt: "Are you sure you want to delete docs version {{.VERSION}}? This cannot be undone."
    cmds:
      - |
        docker run --rm -v {{.ROOT_DIR}}:/docs -v ~/.gitconfig:/root/.gitconfig:ro \
          -v ~/.ssh:/root/.ssh:ro \
          -w /docs squidfunk/mkdocs-material \
          sh -c "pip install mike && mike delete {{.VERSION}} --push"
      - echo "Documentation version {{.VERSION}} deleted."

  # =============================================================================
  # VHS screen recording tasks
  # =============================================================================

  vhs:all:
    desc: Generate all VHS recordings in correct dependency order
    deps: [build]
    env:
      PATH:
        sh: echo "bin:$PATH"
    cmds:
      - mkdir -p docs/assets/vhs
      # Standalone commands (no prerequisites)
      - vhs vhs/doctor.tape
      - vhs vhs/init.tape
      - vhs vhs/up.tape
      - vhs vhs/cluster-list.tape
      # Commands requiring config file (init runs first in tape)
      - vhs vhs/validate.tape
      - vhs vhs/status.tape
      - vhs vhs/config-show.tape
      - vhs vhs/config-diff.tape
      # Commands requiring cluster (assumes cluster exists)
      - vhs vhs/logs.tape
      - vhs vhs/diagnostics.tape
      - vhs vhs/chart-list.tape
      - vhs vhs/provider-list.tape
      - vhs vhs/credentials-list.tape
      - vhs vhs/down.tape

  vhs:single:
    desc: "Generate single VHS recording (usage: task vhs:single TAPE=init)"
    requires:
      vars: [TAPE]
    deps: [build]
    env:
      PATH:
        sh: echo "bin:$PATH"
    cmds:
      - mkdir -p docs/assets/vhs
      - vhs "vhs/{{.TAPE}}.tape"

  vhs:clean:
    desc: Remove generated VHS recordings
    cmds:
      - rm -rf docs/assets/vhs/*.gif

  dev:run-smoke-up:
    desc: "Run smoke test for up command"
    deps: [build]
    dir: bin
    cmds:
      - ./{{.BINARY_NAME}} down --force
      - ./{{.BINARY_NAME}} up
      - ./{{.BINARY_NAME}} status
      - ./{{.BINARY_NAME}} down --force
  dev:pre-commit:
    desc: "Run pre-commit checks"
    deps: [lint, test]
    cmds:
      - task: lint
      - task: test
      - task: docs:generate
      - task: schema:generate
      - task: vhs:all
